# Building a Maze Solver: finding paths through logic and code.

[< Back Home](/projects/)


<video width="600" controls autoplay muted loop>
  <source src="/videos/maze-solver-showcase.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

> "I wanted to explore algorithms beyond the textbook, 
> so I built a maze generator and a solver from scratch. 
> It's walls, passages, and the quiet logic of search - part puzzle, part pathfinding, 
> and all code."

[View on GitHub](https://github.com/miciukas69x/maze_solver)

## Introduction

This project is a program that generates random mazes and then solves them step by step. I built it to practice recursion, breadth-first search, depth-first search, and handling both logic and visuals at the same time. Itâ€™s where algorithms stop being abstract and start drawing paths you can see.

## Core Features

- Maze generation: random walls, unique entrance and exit.
- Pathfinding: implemented DFS and BFS(not yet) to navigate the maze.
- Visualization: shows the maze and the solving process in real time.
- Backtracking: highlights explored dead ends with different colors.
- Unit tests: seperated pure logic from drawing so the algorithms can be tested cleanly.

## What I Learned

- Applied the theory (DFS, BFS) I've learned taking the DSA course. 
- How to combine recursion and state tracking without getting lost.
- Why separating logic from rendering makes testing and debugging easier.
- How small algorithms can come alive visually with just a few drawing calls.

## Conclusion

This project showed me that algorithms aren't just abstract puzzles - they can literally carve paths. Building the maze solver gave me hands-on experience with recursion, search strategies and visualization, while proving that algorithms practice can also be interactive and fun.
